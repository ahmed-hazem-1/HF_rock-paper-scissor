<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Rock Paper Scissors - YOLO</title>
	<style>
		:root { --bg:#0f1115; --accent:#6366f1; --accent2:#10b981; --danger:#ef4444; --warn:#f59e0b; }
		* { box-sizing:border-box; font-family: system-ui, Arial, sans-serif; }
		body { margin:0; background:linear-gradient(135deg,#0f1115,#1e293b); color:#f1f5f9; min-height:100vh; display:flex; flex-direction:column; }
		header { padding:1rem 1.5rem; background:#111827aa; backdrop-filter:blur(8px); display:flex; justify-content:space-between; align-items:center; }
		h1 { font-size:1.2rem; margin:0; letter-spacing:.5px; }
		main { flex:1; display:flex; flex-direction:column; gap:1rem; padding:1rem; max-width:1400px; width:100%; margin:0 auto; }
		.controls { display:flex; flex-wrap:wrap; gap:.75rem; align-items:center; background:#1e293b; padding:1rem; border-radius:12px; box-shadow:0 4px 10px -2px #000; }
		.rounds-control { display:flex; flex-direction:column; align-items:center; gap:.25rem; }
		.game-buttons { display:flex; gap:.6rem; align-items:center; }
		.game-meta { margin-left:auto; text-align:right; font-size:.75rem; opacity:.7; }
		label { font-size:.85rem; text-transform:uppercase; opacity:.8; letter-spacing:.5px; }
		input[type=number]{ width:80px; padding:.5rem .6rem; border:1px solid #334155; border-radius:8px; background:#0f172a; color:#f8fafc; }
		button { cursor:pointer; border:none; padding:.65rem 1.1rem; font-weight:600; border-radius:10px; background:var(--accent); color:#fff; display:inline-flex; align-items:center; gap:.5rem; box-shadow:0 4px 14px -4px #6366f1; transition:.25s; }
		button.secondary { background:#334155; box-shadow:none; }
		button.danger { background:var(--danger); }
		button:disabled { opacity:.5; cursor:not-allowed; }
		button:hover:not(:disabled){ transform:translateY(-2px); box-shadow:0 8px 20px -6px #6366f1; }
		
		/* Touch device optimizations */
		@media (hover: none) and (pointer: coarse) {
			button:hover:not(:disabled) { transform:none; box-shadow:0 4px 14px -4px #6366f1; }
			button:active:not(:disabled) { transform:scale(0.98); }
		}
		.layout { display:flex; flex:1; gap:1rem; min-height:420px; }
		.panel { flex:1; position:relative; background:#0f172a; border:1px solid #1e293b; border-radius:14px; overflow:hidden; display:flex; flex-direction:column; }
		.panel h2 { margin:0; font-size:.9rem; padding:.6rem .9rem; background:#111827; border-bottom:1px solid #1e293b; letter-spacing:.5px; text-transform:uppercase; }
		.video-wrapper { flex:1; position:relative; display:flex; align-items:center; justify-content:center; }
		#video { width:100%; height:100%; object-fit:cover; background:#020617; }
		.computer-anim { width:100%; height:100%; display:flex; align-items:center; justify-content:center; font-size:6rem; font-weight:700; letter-spacing:2px; color:#64748b; }
		.scoreboard { display:grid; grid-template-columns:repeat(auto-fit,minmax(120px,1fr)); gap:.75rem; margin-top:1rem; }
		.scorebox { background:#1e293b; padding:.9rem .9rem .8rem; border-radius:12px; position:relative; overflow:hidden; }
		.scorebox span.label { display:block; font-size:.65rem; text-transform:uppercase; opacity:.7; letter-spacing:.5px; margin-bottom:.35rem; }
		.big { font-size:1.4rem; font-weight:700; }
		.status { margin-top:.5rem; padding: .85rem 1rem; background:#111827; border:1px solid #1e293b; border-radius:12px; font-size:.9rem; min-height:54px; display:flex; align-items:center; }
		.winner-banner { position:fixed; inset:0; background:#000c; display:none; align-items:center; justify-content:center; z-index:50; flex-direction:column; }
		.winner-banner.active { display:flex; animation:fade .6s ease; }
		.winner-banner h2 { font-size:3rem; margin:.5rem 0; text-shadow:0 6px 25px #000; }
		.confetti { position:fixed; inset:0; pointer-events:none; overflow:hidden; z-index:60; }
		@keyframes fall { to { transform:translateY(110vh) rotate(var(--rot)); opacity:0.9; } }
		@keyframes fade { from { opacity:0; transform:scale(.9);} }
		@keyframes pulse { 0%, 100% { transform:scale(1); } 50% { transform:scale(1.1); } }
		@keyframes bounce { 0%, 100% { transform:scale(1); } 50% { transform:scale(1.2); } }
		.countdown-overlay { position:fixed; inset:0; background:#000a; display:none; align-items:center; justify-content:center; z-index:100; flex-direction:column; }
		.countdown-overlay.active { display:flex; animation:fade .3s ease; }
		.countdown-number { font-size:8rem; font-weight:900; text-shadow:0 8px 30px #000; color:#6366f1; animation:pulse .8s ease-in-out; }
		.round-result-overlay { position:fixed; inset:0; background:#000a; display:none; align-items:center; justify-content:center; z-index:100; flex-direction:column; }
		.round-result-overlay.active { display:flex; animation:fade .5s ease; }
		.round-result { text-align:center; padding:2rem; background:#1e293b; border-radius:20px; border:2px solid #6366f1; max-width:400px; }
		.round-result h3 { font-size:2rem; margin:.5rem 0; }
		.round-result .moves { display:flex; gap:2rem; justify-content:center; align-items:center; margin:1rem 0; }
		.round-result .move { display:flex; flex-direction:column; align-items:center; gap:.5rem; }
		.round-result .move-emoji { font-size:3rem; }
		.round-result .move-label { font-size:.9rem; opacity:.8; }
		
		/* Canvas overlay for bounding boxes */
		#bbox-canvas { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:10; }
		
		/* Mobile responsive design */
		@media (max-width: 768px) {
			.layout { flex-direction:column; gap:.8rem; }
			.panel { min-height:250px; }
			.controls { flex-direction:column; align-items:stretch; gap:.8rem; }
			.game-buttons { justify-content:center; }
			.game-meta { text-align:center; margin:0; }
			header { padding:.8rem 1rem; }
			h1 { font-size:1.1rem; }
			main { padding:.8rem; gap:.8rem; }
			.computer-anim { font-size:4rem; }
			.winner-banner h2 { font-size:2rem; }
			.countdown-number { font-size:6rem; }
			.round-result h3 { font-size:1.5rem; }
			.round-result .move-emoji { font-size:2.5rem; }
			.round-result .moves { gap:1.5rem; }
		}
		
		@media (max-width: 480px) {
			.scoreboard { grid-template-columns:1fr 1fr; gap:.6rem; }
			.computer-anim { font-size:3rem; }
			.countdown-number { font-size:5rem; }
			.round-result { padding:1.5rem; max-width:320px; }
		}
		
		/* Landscape orientation on mobile */
		@media (max-height: 500px) and (orientation: landscape) {
			.layout { flex-direction:row; }
			.panel { min-height:200px; }
			.computer-anim { font-size:3rem; }
			.countdown-number { font-size:4rem; }
		}
	</style>
</head>
<body>
	<header>
		<h1>🎮 Rock Paper Scissors</h1>
		<div style="font-size:.75rem; opacity:.7;">Powered by YOLO AI</div>
	</header>
	
	<main>
		<div class="controls">
			<div class="rounds-control">
				<label for="rounds">Rounds</label>
				<input type="number" id="rounds" value="3" min="1" max="10" />
			</div>
			
			<div class="game-buttons">
				<button id="startBtn">🎯 Start Game</button>
				<button id="resetBtn" class="secondary">🔄 Reset</button>
			</div>
			
			<div class="game-meta">
				<div>Confidence threshold: 50%</div>
				<div>Detection: Auto mode</div>
			</div>
		</div>
		
		<div class="layout">
			<div class="panel">
				<h2>📹 Your Camera</h2>
				<div class="video-wrapper">
					<video id="video" autoplay playsinline></video>
					<canvas id="bbox-canvas"></canvas>
				</div>
			</div>
			
			<div class="panel">
				<h2>🤖 Computer</h2>
				<div class="computer-anim" id="computerDisplay">Ready to play!</div>
			</div>
		</div>
		
		<div class="scoreboard">
			<div class="scorebox">
				<span class="label">Player Score</span>
				<div class="big" id="playerScore">0</div>
			</div>
			<div class="scorebox">
				<span class="label">Computer Score</span>
				<div class="big" id="computerScore">0</div>
			</div>
			<div class="scorebox">
				<span class="label">Current Round</span>
				<div class="big" id="currentRound">0</div>
			</div>
			<div class="scorebox">
				<span class="label">Last Move</span>
				<div class="big" id="lastMove">-</div>
			</div>
		</div>
		
		<div class="status" id="status">
			Click "Start Game" to begin. Make sure your camera is working!
		</div>
	</main>
	
	<!-- Winner announcement overlay -->
	<div class="winner-banner" id="winnerBanner">
		<div class="confetti" id="confetti"></div>
		<h2 id="winnerText">🎉 You Win!</h2>
		<p id="winnerSubtext">Final score: 3-2</p>
		<button onclick="closeWinnerBanner()" style="margin-top:1rem;">Play Again</button>
	</div>
	
	<!-- Countdown overlay -->
	<div class="countdown-overlay" id="countdownOverlay">
		<div class="countdown-number" id="countdownNumber">3</div>
		<p style="font-size:1.2rem; margin-top:1rem; opacity:.8;">Get ready...</p>
	</div>
	
	<!-- Round result overlay -->
	<div class="round-result-overlay" id="roundResultOverlay">
		<div class="round-result">
			<h3 id="roundResultTitle">Round 1 Result</h3>
			<div class="moves">
				<div class="move">
					<div class="move-emoji" id="playerMoveEmoji">✊</div>
					<div class="move-label">You</div>
				</div>
				<div style="font-size:2rem; opacity:.6;">vs</div>
				<div class="move">
					<div class="move-emoji" id="computerMoveEmoji">✋</div>
					<div class="move-label">Computer</div>
				</div>
			</div>
			<p id="roundResultText">Computer wins this round!</p>
			<button onclick="closeRoundResult()" style="margin-top:1rem;">Continue</button>
		</div>
	</div>

	<script>
		// Configuration
		const CONFIDENCE_THRESHOLD = 0.5;
		const DETECTION_INTERVAL = 500;
		const COUNTDOWN_DURATION = 3;
		
		// Game state
		let gameActive = false;
		let playerScore = 0;
		let computerScore = 0;
		let currentRound = 0;
		let maxRounds = 3;
		let roundInProgress = false;
		let lastDetectionTime = 0;
		let currentPlayerMove = null;
		let detectionCooldown = false;
		
		// ⚠️ REPLACE THIS URL WITH YOUR HUGGING FACE SPACE URL
		const API_BASE = 'https://ahmedhazemelabady-rock-paper-scissor.hf.space';
		
		// Move emojis
		const moveEmojis = {
			'rock': '✊',
			'paper': '✋', 
			'scissors': '✌️'
		};
		
		// DOM elements
		const video = document.getElementById('video');
		const canvas = document.getElementById('bbox-canvas');
		const ctx = canvas.getContext('2d');
		const startBtn = document.getElementById('startBtn');
		const resetBtn = document.getElementById('resetBtn');
		const roundsInput = document.getElementById('rounds');
		const status = document.getElementById('status');
		const playerScoreEl = document.getElementById('playerScore');
		const computerScoreEl = document.getElementById('computerScore');
		const currentRoundEl = document.getElementById('currentRound');
		const lastMoveEl = document.getElementById('lastMove');
		const computerDisplay = document.getElementById('computerDisplay');
		const winnerBanner = document.getElementById('winnerBanner');
		const countdownOverlay = document.getElementById('countdownOverlay');
		const roundResultOverlay = document.getElementById('roundResultOverlay');
		
		// Initialize camera
		async function initCamera() {
			try {
				const stream = await navigator.mediaDevices.getUserMedia({ 
					video: { facingMode: 'user' } 
				});
				video.srcObject = stream;
				
				video.addEventListener('loadedmetadata', () => {
					canvas.width = video.videoWidth;
					canvas.height = video.videoHeight;
				});
				
				updateStatus('✅ Camera ready! Click "Start Game" to begin.');
			} catch (err) {
				console.error('Camera error:', err);
				updateStatus('❌ Camera access denied. Please allow camera permissions.');
			}
		}
		
		// Canvas resizing
		function resizeCanvas() {
			const rect = video.getBoundingClientRect();
			canvas.style.width = rect.width + 'px';
			canvas.style.height = rect.height + 'px';
		}
		
		window.addEventListener('resize', resizeCanvas);
		video.addEventListener('loadedmetadata', resizeCanvas);
		
		// Bounding box drawing
		function drawBoundingBox(bbox, confidence, prediction) {
			if (!bbox) return;
			
			const rect = video.getBoundingClientRect();
			const scaleX = canvas.width / video.videoWidth;
			const scaleY = canvas.height / video.videoHeight;
			
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			
			// Draw bounding box
			ctx.strokeStyle = '#6366f1';
			ctx.lineWidth = 3;
			ctx.setLineDash([]);
			
			const x = bbox.x1 * scaleX;
			const y = bbox.y1 * scaleY;
			const width = (bbox.x2 - bbox.x1) * scaleX;
			const height = (bbox.y2 - bbox.y1) * scaleY;
			
			ctx.strokeRect(x, y, width, height);
			
			// Draw label background
			ctx.fillStyle = '#6366f1';
			const labelText = `${prediction} (${Math.round(confidence * 100)}%)`;
			ctx.font = '16px system-ui';
			const textWidth = ctx.measureText(labelText).width;
			ctx.fillRect(x, y - 25, textWidth + 10, 25);
			
			// Draw label text
			ctx.fillStyle = 'white';
			ctx.fillText(labelText, x + 5, y - 8);
		}
		
		// Computer display animations
		function updateComputerDisplay(text, emoji = null) {
			if (emoji) {
				computerDisplay.innerHTML = `
					<div style="animation: bounce 0.6s ease-in-out;">${emoji}</div>
					<div style="font-size: 1.5rem; margin-top: 0.5rem;">${text}</div>
				`;
			} else {
				computerDisplay.textContent = text;
			}
		}
		
		// Countdown display
		function showCountdown() {
			return new Promise((resolve) => {
				countdownOverlay.classList.add('active');
				let count = COUNTDOWN_DURATION;
				
				const countdownNumber = document.getElementById('countdownNumber');
				countdownNumber.textContent = count;
				
				const interval = setInterval(() => {
					count--;
					if (count > 0) {
						countdownNumber.textContent = count;
					} else {
						countdownNumber.textContent = 'GO!';
						setTimeout(() => {
							countdownOverlay.classList.remove('active');
							clearInterval(interval);
							resolve();
						}, 500);
					}
				}, 1000);
			});
		}
		
		// Round result display
		function showRoundResult(playerMove, computerMove, winner, roundNum) {
			const title = document.getElementById('roundResultTitle');
			const playerEmoji = document.getElementById('playerMoveEmoji');
			const computerEmoji = document.getElementById('computerMoveEmoji');
			const resultText = document.getElementById('roundResultText');
			
			title.textContent = `Round ${roundNum} Result`;
			playerEmoji.textContent = moveEmojis[playerMove] || '❓';
			computerEmoji.textContent = moveEmojis[computerMove] || '❓';
			
			if (winner === 'player') {
				resultText.textContent = 'You win this round!';
				resultText.style.color = '#10b981';
			} else if (winner === 'computer') {
				resultText.textContent = 'Computer wins this round!';
				resultText.style.color = '#ef4444';
			} else {
				resultText.textContent = "It's a tie!";
				resultText.style.color = '#f59e0b';
			}
			
			roundResultOverlay.classList.add('active');
		}
		
		function closeRoundResult() {
			roundResultOverlay.classList.remove('active');
		}
		
		// Game logic
		function getComputerMove() {
			const moves = ['rock', 'paper', 'scissors'];
			return moves[Math.floor(Math.random() * moves.length)];
		}
		
		function determineWinner(playerMove, computerMove) {
			if (playerMove === computerMove) return 'tie';
			
			const winning = {
				'rock': 'scissors',
				'paper': 'rock', 
				'scissors': 'paper'
			};
			
			return winning[playerMove] === computerMove ? 'player' : 'computer';
		}
		
		async function playRound(playerMove) {
			if (roundInProgress || !gameActive) return;
			
			roundInProgress = true;
			currentRound++;
			
			updateStatus('🎮 Round in progress...');
			updateComputerDisplay('Thinking...', '🤔');
			
			// Show countdown
			await showCountdown();
			
			// Get computer move
			const computerMove = getComputerMove();
			updateComputerDisplay(computerMove.toUpperCase(), moveEmojis[computerMove]);
			
			// Determine winner
			const winner = determineWinner(playerMove, computerMove);
			
			// Update scores
			if (winner === 'player') {
				playerScore++;
			} else if (winner === 'computer') {
				computerScore++;
			}
			
			// Update display
			updateScoreboard();
			lastMoveEl.textContent = moveEmojis[playerMove];
			
			// Show round result
			setTimeout(() => {
				showRoundResult(playerMove, computerMove, winner, currentRound);
			}, 1000);
			
			// Check if game is over
			setTimeout(() => {
				if (currentRound >= maxRounds) {
					endGame();
				} else {
					roundInProgress = false;
					updateStatus('👀 Show your move to the camera!');
					updateComputerDisplay('Waiting for your move...', '⏳');
				}
			}, 3000);
		}
		
		// Detection function
		async function detectGesture() {
			if (!gameActive || roundInProgress || detectionCooldown) return;
			
			const now = Date.now();
			if (now - lastDetectionTime < DETECTION_INTERVAL) return;
			lastDetectionTime = now;
			
			try {
				// Capture frame from video
				const canvas = document.createElement('canvas');
				canvas.width = video.videoWidth;
				canvas.height = video.videoHeight;
				const ctx = canvas.getContext('2d');
				ctx.drawImage(video, 0, 0);
				
				// Convert to blob
				const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.8));
				
				const formData = new FormData();
				formData.append('file', blob, 'frame.jpg');
				
				const res = await fetch(API_BASE + '/detect', { 
					method: 'POST',
					body: formData
				});
				
				if (!res.ok) {
					throw new Error(`HTTP ${res.status}: ${res.statusText}`);
				}
				
				const data = await res.json();
				
				if (data.prediction && data.confidence >= CONFIDENCE_THRESHOLD) {
					// Draw bounding box
					drawBoundingBox(data.bounding_box, data.confidence, data.prediction);
					
					// Trigger round
					detectionCooldown = true;
					setTimeout(() => { detectionCooldown = false; }, 2000);
					
					await playRound(data.prediction);
				} else {
					// Clear canvas if no detection
					ctx.clearRect(0, 0, canvas.width, canvas.height);
				}
				
			} catch (error) {
				console.error('Detection error:', error);
				updateStatus(`❌ Detection failed: ${error.message}`);
			}
		}
		
		// Game control functions
		function startGame() {
			maxRounds = parseInt(roundsInput.value) || 3;
			playerScore = 0;
			computerScore = 0;
			currentRound = 0;
			gameActive = true;
			roundInProgress = false;
			
			updateScoreboard();
			updateStatus('👀 Show your move to the camera!');
			updateComputerDisplay('Waiting for your move...', '⏳');
			
			startBtn.disabled = true;
			roundsInput.disabled = true;
			
			// Start detection loop
			const detectionLoop = setInterval(() => {
				if (!gameActive) {
					clearInterval(detectionLoop);
					return;
				}
				detectGesture();
			}, 100);
		}
		
		function resetGame() {
			gameActive = false;
			roundInProgress = false;
			playerScore = 0;
			computerScore = 0;
			currentRound = 0;
			
			updateScoreboard();
			updateStatus('Click "Start Game" to begin. Make sure your camera is working!');
			updateComputerDisplay('Ready to play!');
			
			startBtn.disabled = false;
			roundsInput.disabled = false;
			
			// Clear canvas
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			lastMoveEl.textContent = '-';
			
			// Close any open overlays
			winnerBanner.classList.remove('active');
			countdownOverlay.classList.remove('active');
			roundResultOverlay.classList.remove('active');
		}
		
		function endGame() {
			gameActive = false;
			roundInProgress = false;
			
			const finalWinner = playerScore > computerScore ? 'player' : 
							  computerScore > playerScore ? 'computer' : 'tie';
			
			// Show winner banner
			setTimeout(() => {
				showWinnerBanner(finalWinner);
				// Auto-reset after showing winner
				setTimeout(resetGame, 5000);
			}, 1000);
		}
		
		function updateScoreboard() {
			playerScoreEl.textContent = playerScore;
			computerScoreEl.textContent = computerScore;
			currentRoundEl.textContent = currentRound;
		}
		
		function updateStatus(message) {
			status.textContent = message;
		}
		
		function showWinnerBanner(winner) {
			const winnerText = document.getElementById('winnerText');
			const winnerSubtext = document.getElementById('winnerSubtext');
			
			if (winner === 'player') {
				winnerText.textContent = '🎉 You Win!';
				createConfetti();
			} else if (winner === 'computer') {
				winnerText.textContent = '🤖 Computer Wins!';
			} else {
				winnerText.textContent = '🤝 It\'s a Tie!';
			}
			
			winnerSubtext.textContent = `Final score: ${playerScore}-${computerScore}`;
			winnerBanner.classList.add('active');
		}
		
		function closeWinnerBanner() {
			winnerBanner.classList.remove('active');
			resetGame();
		}
		
		function createConfetti() {
			const confetti = document.getElementById('confetti');
			confetti.innerHTML = '';
			
			const colors = ['#6366f1', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6'];
			
			for (let i = 0; i < 50; i++) {
				const piece = document.createElement('div');
				piece.style.cssText = `
					position: absolute;
					width: 10px;
					height: 10px;
					background: ${colors[Math.floor(Math.random() * colors.length)]};
					left: ${Math.random() * 100}%;
					animation: fall ${2 + Math.random() * 3}s linear forwards;
					--rot: ${Math.random() * 360}deg;
				`;
				confetti.appendChild(piece);
			}
		}
		
		// API health check
		async function checkAPI() {
			try {
				const r = await fetch(API_BASE + '/health'); 
				const data = await r.json();
				console.log('API Status:', data);
				if (!data.model_loaded) {
					updateStatus('⚠️ API model not loaded. Please wait...');
				}
			} catch (err) {
				console.error('API Error:', err);
				updateStatus('❌ Cannot connect to API. Please check your internet connection.');
			}
		}
		
		// Event listeners
		startBtn.addEventListener('click', startGame);
		resetBtn.addEventListener('click', resetGame);
		
		// Initialize
		initCamera();
		checkAPI();
	</script>
</body>
</html>
